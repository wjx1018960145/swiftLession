//: [上一页](@previous)

import Foundation




//初始化器 类，结构体，枚举都可以定义初始化器
// 类有两种初始化器，指定初始化器，便捷初始化器
// 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器
// 默认初始化器总是类的指定初始化器
// 类偏向于少量指定初始化器，一个类通常只有一个指定初始化器

//初始化器的相互调用规则
//: -指定初始化器必须从它的直系父类调用指定的初始化器
//: - 便捷初始化器必须从相同的类里调用另一个初始化器
//: - 便捷初始化器最终必须调用一个指定初始化器


// 初始化器的相互调用


/*
 
 designated <-Convenicence<-Convenience
    ^
    |


 **/

//两段式初始化

// swift 哎编码安全方面是煞费苦心 为了保证初始化过程安全，设定了两段式初始化，安全检查

// 两段式初始化
// 第一阶段 初始化多所有的存储属性
//1 外层调用指定便捷初始化器
//2 分配内存给实例，但未初始化
//3 指定初始化器确保当前类定义的存储属性都初始化
//4 指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链

// 第二阶段 设置新的存储属性
//1 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例
//2 初始化器现在能够使用self（访问，修改的属性，调用它的实例方法等等）
//3 最终，链中任何便捷初始化器都有机会定制实例以及self


//安全检查
// 指定初始化器必须保证在调用父类初始化器之前，其所再类定义的所有存储属性都要初始化完成
// 指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值
// 便捷初始化器必须先调用同类中的其他初始化器，然后再为任意属性设置新值
// 初始化器在第一阶段初始化完成之前，不能调用人格实例，不能读取任何实例属性的值，也不能引用self
// 直到第一阶段结束，实例才能算完全合法



class Person {
    var age: Int
    var name: String
    init(age: Int, name: String) {
        self.age = age
        self.name = name
    }
    init(age: Int) {
        self.age = age
        self.name = "Jack"
    }
}

class Student: Person {

}

var s1 = Student(age: 10)
var s2 = Student(age: 10, name: "Rose")


// 重写
// 当重写父类的指定初始化器时，必须加上override （即使子类的实现是便捷初始化器）
// 如果子类写了一个匹配父类便捷初始化器的初始化器，不用加override










//: [下一页](@next)
